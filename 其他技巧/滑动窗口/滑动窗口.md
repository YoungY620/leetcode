# 滑动窗口

滑动窗口的特点是向一个方向遍历，因此相比$O(n^2)$复杂度的双指针遍历，滑动窗口中一定有些区间遍历不到。

因此滑动窗口的关键在于理解**为什么这些错过的区间不需要考虑**。

在每篇题解中均强调的：
- 左边界固定时，对应的有边界是固定的
- 左边界向右移动时，对应的右边界也是单增的（向右移动的）
- 许多滑动窗口的题均会问最多、最少之类的问题。因此总会有左边界相同时，长度更长的区间一定不符合要求。

**模板例：** **[最长湍流数组](978.最长湍流子数组.c)**

在滑动过程中，**right** 指针代表在已验证区间右侧第一个待检验的元素，整个循环是以它为基准来迭代、判断的。检查right指针，并更新用于记录状态（例如计数）的变量后，判断是否要移动左指针。

**移动左指针要注意保持状态一致性。** 举例来说，在如下代码中，在执行到“if(maxlen)<len” 这一句时，不需要考虑是否移动过左指针，即len变量始终在这里表示以right为右边界的、符合规则的、左闭右开区间的长度。

```C
# define A ((arr[right]>=arr[right-1]&&arr[right-1]>=arr[right-2])\
    ||(arr[right]<=arr[right-1]&&arr[right-1]<=arr[right-2]))

int maxTurbulenceSize(int* arr, int arrSize){
    int left = 0;
    int right = 0;
    int len = 0;
    int maxlen = 0;

    while(right<arrSize){
        // printf("%d %d\n", left, right);
        len++;
        if(right-left>=2 && A){
            len=0;
            left=--right;
        }else if(right - left == 1 && arr[left] == arr[right]){
            len=0;
            left = right;
        }else{
            right++;
        }
        if(maxlen<len){     // 这一句之前，保持len变量的一致性
            maxlen = len;
        }
    }
    return maxlen;
}
```

**例题：[k-个不同子数组](992.k-个不同整数的子数组.c)**

由于“滑动窗口经常解决最大、最小问题”这一经验，将此问题（恰好k个不同整数）转化为最大问题（最多有k个不同整数）
```C

```