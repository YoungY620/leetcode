# 滑动窗口

## 可行性证明
滑动窗口的特点是向一个方向遍历，因此相比$O(n^2)$复杂度的双指针遍历，滑动窗口中一定有些区间遍历不到。

因此滑动窗口的关键在于理解**为什么这些错过的区间不需要考虑**。

在每篇题解中均强调的：
- 左边界固定时，对应的有边界是固定的
- 左（右）边界向右移动时，对应的右（左）边界也是单增的（不向左移动的）
- 许多滑动窗口的题均会问最多、最少之类的问题。因此总会有左边界相同时，长度更长的区间一定不符合要求。

## 实现要点
- **如何记录（检查、标记）右节点**
  
  最简单的便只是`right++;`，即`right`本身即可作为记录的变量。例如[978最长湍流数组](#978)

  更常见的情况是，使用数组记录元素的存在性或计数。这里可能使用到hash、[单调队列](#239)
- **如何判断需要移动左指针，（以及使用while或if）**

  在滑窗中，只能单方向向右移动左指针，因此判断的条件必须是单方向的（如不符合左指针只需向右移动一位）。
- **如何移动左指针**

  移动左指针需要保证状态一致性，例：[最长湍流数组](#978)

## 实例
<span id='978'></span>

**模板例：** **[最长湍流数组](978.最长湍流子数组.c)**

在滑动过程中，`right` 指针代表在已验证区间右侧第一个待检验的元素，整个循环是以它为基准来迭代、判断的。检查`right`指针，并更新用于记录状态（例如计数）的变量后，判断是否要移动左指针。

**移动左指针要注意保持状态一致性。** 举例来说，在如下代码中，在执行到 `if(maxlen<len)` 这一句时，不需要考虑是否移动过左指针，即len变量始终在这里表示以`right`为右边界的、符合规则的、左闭右开区间的长度。

```C
# define CONDITION ((arr[right]>=arr[right-1]&&arr[right-1]>=arr[right-2])\
    ||(arr[right]<=arr[right-1]&&arr[right-1]<=arr[right-2]))

int maxTurbulenceSize(int* arr, int arrSize){
    int left = 0;
    int right = 0;
    int len = 0;
    int maxlen = 0;

    while(right<arrSize){
        // printf("%d %d\n", left, right);
        len++;
        if(right-left>=2 && CONDITION){
            len=0;
            left=--right;
        }else if(right - left == 1 && arr[left] == arr[right]){
            len=0;
            left = right;
        }else{
            right++;
        }
        if(maxlen<len){     // 这一句之前，保持len变量的一致性
            maxlen = len;
        }
    }
    return maxlen;
}
```
---
<span id='992'></span>

**例题：[k-个不同子数组](992.k-个不同整数的子数组.c)** （转化の思想）

由于“滑动窗口经常解决最大、最小问题”这一经验，将此问题（恰好k个不同整数）转化为最大问题（最多有k个不同整数）
```C
int subarraysWithKDistinct(int* A, int ASize, int K){
    return func(A, ASize, K)-func(A, ASize, K-1);
}
```
其中，func函数为求解**最多包含k个不同整数的子区间个数**，因此`func(A, ASize, K)-func(A, ASize, K-1)` 即为**恰好k个不同整数的子区间个数**

---
<span id='239'></span>

**例题：[滑动窗口最大值](239.滑动窗口最大值.c)**（单调队列）

取该区间的最大值，首先想到的便是（大根）堆。堆的更新和添加需要 $O(log_2n)$ 的时间复杂度，有时会超时。

对于滑动窗口内的最大值，可以使用一个单调队列来找到，**证明**：

由于我们需要求出的是滑动窗口的最大值，如果当前的滑动窗口中有两个下标 `i` 和 `j`，**其中 `i` 在 `j` 的左侧（`i<j`），并且 `i` 对应的元素不大于 `j` 对应的元素（`nums[i]`$\leq$`nums[j]`）** 当滑动窗口向右移动时，只要 `i` 还在窗口中，那么 `j` 一定也还在窗口中，这是 `i` 在 `j` 的左侧所保证的。因此，**由于 `nums[j]` 的存在，`nums[i]` 一定不会是滑动窗口中的最大值了，我们可以将 `nums[i]` 永久地移除**。

因此，我们会不断地将新的元素与队尾的元素相比较，如果前者大于等于后者，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，**直到队列为空或者新的元素小于队尾的元素。**

同时检查滑窗左侧需要移除的元素是否是最大值（队头），若是则弹出队头元素。

为了可以同时弹出队首和队尾的元素，我们需要使用双端队列。满足这种单调性的双端队列一般称作 **「单调队列」** 。