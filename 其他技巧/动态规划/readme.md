# 动态规划

[toc]

## 关键思路：
- **确定dp状态**
  - **最优子结构**：每个dp状态都是由更小规模的dp问题推出的
  - **无后效性**：某一状态值获取的方式，不影响后续的其他值
- **状态转移方程**：实质上，dp状态方程和dp状态是一体的，是否无后效性、是否为最优子结构，也经常需要借助转移方程来判断

## 基础模型
- 线性dp
  - [最长递增子序列（LIS）](#最长递增子序列lis)
  - [最长公共子序列（LCS）](#最长公共子序列lcs)
  - [数字三角形](#数字三角形)
  - [背包问题](#背包问题)

### 最长递增子序列（LIS）
**原型例题：[300.最长递增子序列LIS](LIS/300.最长递增子序列LIS.c)**

本质上，待求解的数组是一个有向无环图，每条边的起点一定在终点的右侧且大于中点值。

更关键的是，所有边的终点都指向起点的左侧，这保证了后续的状态方程是无后效性的。

思路：
- 状态 `dp[i]` 为 “ 以 `nums[i]` 为末尾的子序列的最大长度 ”
- 转移方程： $dp[i]=\max(1, dp[j]+1), 0\leq j < i, nums[j]<nums[i]$

此外因为本题是有向无环图，因此还可以使用拓扑排序的方法，只是复杂度更高：[300.LIS拓扑排序](LIS/300.最长递增子序列LIS拓扑排序.c)
  
**变形：[354.套娃信封](LIS/354.俄罗斯套娃信封问题.c)**

在此题中，信封之间依然存在单向的关系，可以抽象为有向无环图，但不满足终点在起点的左侧。因此我们队信封序列按长或宽进行排序，这样，任意信封可以容纳的信封一定都在其左侧。

### 最长公共子序列（LCS）

一个最基本的双串匹配 dp 问题. 

思路: 
- `dp[i][j]` 表示 `s1` 的前 i 个字符与 `s2` 中的前 j 个字符中最长公共子序列长度
- 转移:
  - 若 `s1[i] == s2[j]` 则 `dp[i][j] == dp[i-1][j-1]`
  - 若 `s1[i] != s2[j]` 则 `dp[i][j] = max(dp[i][j-1], dp[i-1][j])`

### 数字三角形

**原型例题:**[120.三角形最小路径](120.三角形最小路径和.java)

该模型的重要意义在于告诉了我们二维坐标系中也是可以进行「线性 DP」的，而且我们可以直接**根据坐标点设置「DP 状态」**。

### 背包问题

#### 概述

- **记住共同点**:  
  - dp状态 `dp[i][j]` 为**只考虑前 `i` 个物品, 且背包容积 (`v`) 为 `j` 时背包能装物品的最大重量 (`w`)**.
  之后会根据情况进行空间优化
- 分为 3 类: **0-1背包, 完全背包, 多重背包**

#### 0-1 背包

- 对于每个物品只有取或不取两种可能. 
    - 取, 则总价值为 `dp[i][j] = dp[i-1][j-v[i]] + w[i]`, 
    - 不取, 则保持原样: `dp[i][j] = dp[i-1][j]`
- 滚动数组: `dp[i][j]` 只与其左侧的元素有关, 因此可以 `dp[i]` 从左至右遍历

#### 完全背包

- 这里数学代换:
  - 首先沿用0-1背包 `dp`, 直译题意, 有

    ![](img/Web%20capture_24-4-2021_14529_.jpeg)

    整理

    ![](img/Web%20capture_24-4-2021_145045_.jpeg)

    又由 (1) 式, 令 $j = j-v[i]$ 

    ![](img/Web%20capture_24-4-2021_14532_.jpeg)

    将 (3) 式代入 (2) 式得:

    ![](img/Web%20capture_24-4-2021_145335_.jpeg)

- 滚动数组: `dp[j]` 表示背包容量为 `j` 时, 从左至右.

#### 多重背包

- 依然由0-1引申而来, 使用**二进制拆分**将 `c[i]` 个相同物品 `i` 分为多个不同的物体
- 二进制拆分的合理性在于, 分量之间不相关, 彼此正交, 同时可以表示出所有整数

### 排列组合问题（极像背包问题）

- 排列组合问题, 要素：
  - 待选集 `nums`
  - 目标值 `target`
  - 要求, 从 `nums` 中选, 总和**正好等于** `target`
- 可能变种?: 
  - `nums` 能否重复选?
  - 是否考虑顺序, 即相同物品不同顺序算不同方案

#### 可重复选且考虑顺序的情况

- 定义
  - `f[len][tar]` 表示在考虑前 `len` 个物品时, 总重达到 `tar` 有多少方案
  - 最终解即 `f[nums.length][target]`

    ![](img/Web%20capture_24-4-2021_144332_leetcode-cn.com.jpeg)

  - 同样可以滚动数组优化:

    ![](img/Web%20capture_24-4-2021_144454_leetcode-cn.com.jpeg)
  
  - 具体技巧:
    - 当考虑顺序时, 则 target 在外侧循环, 内测遍历 nums:

    ```python
    for t in range(target):
        for num in nums:
            if nums <= t: 
                f[t] += f[t-num]
    ```
      
    - 而背包问题不考虑顺序, 因此 外侧遍历 nums, 内测遍历 target

    ```python
    for num in nums:
        for i in range(target):
            pass
    ```

- 模板题: [组合总和](377.组合总和-ⅳ.cpp)

### 其他例题

- [丑数2](https://leetcode-cn.com/problems/ugly-number-ii/)
  - 理解 `2, 3, 5` 公倍数递增的规律:
    - 三个因数, 维护三个指针, 每次取大于当前值的最小值.